#if 0
int areIntersecting(Segment side1, Segment side2){
    float d1, d2;
    float a1, a2, b1, b2, c1, c2;

    // Convert vector 1 to a line (line 1) of infinite length.
    // We want the line in linear equation standard form: A*x + B*y + C = 0
    // See: http://en.wikipedia.org/wiki/Linear_equation
    a1 = side1.p2.latitude - side1.p1.latitude;
    b1 = side1.p1.longitude - side1.p2.longitude;
    c1 = (side1.p2.longitude * side1.p1.latitude) - (side1.p1.longitude * side1.p2.latitude);

    // Every point (x,y), that solves the equation above, is on the line,
    // every point that does not solve it, is not. The equation will have a
    // positive result if it is on one side of the line and a negative one 
    // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector
    // 2 into the equation above.
    d1 = (a1 * side2.p1.longitude) + (b1 * side2.p1.latitude) + c1;
    d2 = (a1 * side2.p2.longitude) + (b1 * side2.p2.latitude) + c1;

    // If d1 and d2 both have the same sign, they are both on the same side
    // of our line 1 and in that case no intersection is possible. Careful, 
    // 0 is a special case, that's why we don't test ">=" and "<=", 
    // but "<" and ">".
    if (d1 > 0 && d2 > 0) return 0;
    if (d1 < 0 && d2 < 0) return 0;

    // The fact that vector 2 intersected the infinite line 1 above doesn't 
    // mean it also intersects the vector 1. Vector 1 is only a subset of that
    // infinite line 1, so it may have intersected that line before the vector
    // started or after it ended. To k0w for sure, we have to repeat the
    // the same test the other way round. We start by calculating the 
    // infinite line 2 in linear equation standard form.
    a2 = side2.p2.latitude - side2.p1.latitude;
    b2 = side2.p1.longitude - side2.p2.longitude;
    c2 = (side2.p2.longitude * side2.p1.latitude) - (side2.p1.longitude * side2.p2.latitude);

    // Calculate d1 and d2 again, this time using points of vector 1.
    d1 = (a2 * side1.p1.longitude) + (b2 * side1.p1.latitude) + c2;
    d2 = (a2 * side1.p2.longitude) + (b2 * side1.p2.latitude) + c2;

    // Again, if both have the same sign (and neither one is 0),
    // 0 intersection is possible.
    if (d1 > 0 && d2 > 0) return 0;
    if (d1 < 0 && d2 < 0) return 0;

    // If we get here, only two possibilities are left. Either the two
    // vectors intersect in exactly one point or they are collinear, which
    // means they intersect in any number of points from zero to infinite.
    if ((a1 * b2) - (a2 * b1) == 0.0f) return 2;

    // If they are not collinear, they must intersect in exactly one point.
    return 1;
}


//TODO: ray, and sides like (x1/y1)-(x2/y2)
bool isSampleInRangeGeneral(GPSSamp* samp, Zone_general* zone_gen){
	// find X,Y min and max each.
	double Xmin = 190, Xmax = -1;
	double Ymin = 100, Ymax = -1;
	int i;
	for(i = 0; i < zone_gen->numVertices; i++){
		printf("x%d: %f, y%d: %f || ",i, i, zone_gen->vertices[i].longitude, zone_gen->vertices[i].latitude);
		if(zone_gen->vertices[i].longitude < Xmin)
			Xmin = zone_gen->vertices[i].longitude;
		if(zone_gen->vertices[i].latitude < Ymin)
			Ymin = zone_gen->vertices[i].latitude; 
	}
	for(i = 0; i < zone_gen->numVertices; i++){
		if(zone_gen->vertices[i].longitude > Xmax)
			Xmax = zone_gen->vertices[i].longitude;
		if(zone_gen->vertices[i].latitude > Ymax)
			Ymax = zone_gen->vertices[i].latitude; 
	}
	printf("xmin: %f, xmax: %f, ymin: %f, ymax: %f\n", Xmin, Xmax, Ymin, Ymax);
	double e = ((Xmax - Xmin) / 100);

	Segment sides[zone_gen->numVertices];
	//double sidesCalc[zone_gen->numVertices];
	for(i = 0; i < zone_gen->numVertices-1; i++){
		sides[i].p1.longitude = zone_gen->vertices[i].longitude;
		sides[i].p1.latitude = zone_gen->vertices[i].latitude;

		sides[i].p2.longitude = zone_gen->vertices[i+1].longitude;
		sides[i].p2.latitude = zone_gen->vertices[i+1].latitude;
		//sidesCalc[i] = (sides[i].p1.longitude/sides[i].p1.latitude) - 
		//(sides[i].p2.longitude/sides[i].p2.latitude);
	}

	sides[zone_gen->numVertices-1].p1.longitude = zone_gen->vertices[zone_gen->numVertices-1].longitude;
	sides[zone_gen->numVertices-1].p1.latitude = zone_gen->vertices[zone_gen->numVertices-1].latitude;

	sides[zone_gen->numVertices-1].p2.longitude = zone_gen->vertices[0].longitude;
	sides[zone_gen->numVertices-1].p2.latitude = zone_gen->vertices[0].latitude;
	//sidesCalc[zone_gen->numVertices-1] = (sides[zone_gen->numVertices-1].p1.longitude/sides[zone_gen->numVertices-1].p1.latitude) - 
	//	(sides[0].p2.longitude/sides[0].p2.latitude);

	Segment ray = { .p1.longitude = samp->longitude, .p1.latitude = samp->latitude,
					.p2.longitude = Xmax + e, .p2.latitude = samp->latitude };

	//double rayCalc = ( ray.p1.longitude/ray.p1.latitude) - (ray.p2.longitude + ray.p2.latitude);
	
	/* test intersections */
	int intersections = 0;
	for(i = 0; i < zone_gen->numVertices; i++){
		if(areIntersecting(ray, sides[i]))
			intersections++;
	}

	if((intersections % 2) == 1)
		return true; // inside polygon
	return false; //outside
}	
#endif

bool isSampleInRange(GPSSamp* samp, Zone* zone) {
	//The simplest check of a body within a rectangle
	if(samp->altitude > zone->altitude) 
		return false;

	if(samp->latitude >= max(zone->p1.latitude, zone->p2.latitude) || 
		samp->latitude <= min(zone->p1.latitude, zone->p2.latitude))
		return false;

	if(samp->longitude >= max(zone->p1.longitude, zone->p2.longitude) || 
		samp->longitude <= min(zone->p1.longitude, zone->p2.longitude))
		return false;

	return true;
}