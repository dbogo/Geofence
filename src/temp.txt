	/*
	for(size_t i = 0; i < zone->numVertices; i++){
		if(zone->vertices[i].latitude <= p.latitude){
			if(zone->vertices[i+1].latitude > p.latitude){
				if(isLeft(p, edges[i]) > 0){
					++w;
				}
			}
		} else {
			if (zone->vertices[i+1].latitude <= p.latitude){
				if(isLeft(p, edges[i]) < 0){
					--w;
				}
			}
		}
	}*/
	
	/*
	// NOTE: amount of edges = amount of vertices! hence zone->numvertices
	for(size_t i = 0; i < zone->numVertices; i++){
		if(upwards_cross(edges[i], p)){
				if(isLeft(p, edges[i]) > 0){
					++w;
				}
		} else if(downwards_cross(edges[i], p)){ 
			if(isLeft(p, edges[i]) < 0){
				--w;
			}
		}
	}*/
	

	float fu(Zone_general* zone, FullGPSData* loc, Edge* edges){
	int q[zone->numVertices + 1];
	for(size_t i = 0; i <= zone->numVertices; i++){
		if(zone->vertices[i].longitude > loc->longitude && zone->vertices[i].latitude >= loc->latitude)
			q[i] = 0;
		if(zone->vertices[i].longitude <= loc->longitude && zone->vertices[i].latitude > loc->latitude)
			q[i] = 1;
		if(zone->vertices[i].longitude < loc->longitude && zone->vertices[i].latitude <= loc->latitude)
			q[i] = 2;
		if(zone->vertices[i].longitude >= loc->longitude && zone->vertices[i].latitude < loc->latitude)
			q[i] = 3;
	}
	q[zone->numVertices+3] = q[0];

	int w = 0;
	for(size_t i = 0; i <= zone->numVertices; i++){
		switch(q[i+1] - q[i]){
			case 1:
				printf("++\n");
				w = w+1;
				break;
			case -3:
				printf("++\n");
				w = w+1;
				break;
			case -1:
				printf("--\n");
				w = w-1;
				break;
			case 3:
				printf("--\n");
				w = w-1;
				break;
			/*case -2:
				if(det(&edges[i], loc) > 0) 
					w = w+1;
				break;
			case 2:
				if(det(&edges[i], loc) < 0)
					w = w-1;
				break;*/
			case 2:{
				float dt = det(&edges[i], loc);
				if(dt > 0){
					printf("+2\n");
					w = w + 2;
				}if(dt < 0){
					w = w - 2;
					printf("-2\n");
				}
				//w = w + 2*(det(&edges[i], loc) / abs(det(&edges[i], loc)));
				break;
			}
			case -2:{
				float dt = det(&edges[i], loc);
				if(dt > 0){
					printf("+2\n");
					w = w + 2;
				}if(dt < 0){
					w = w - 2;
					printf("-2\n");
				}
				//w = w + 2*(det(&edges[i], loc) / abs(det(&edges[i], loc)));
				break;
			}
			default:
				break;
		}
	}

	return w/4;
}


/*
1. an upward edge includes its starting endpoint, and excludes its final endpoint;
2. a downward edge excludes its starting endpoint, and includes its final endpoint;
3. horizontal edges are excluded
4. the edge-ray intersection point must be strictly right of the point P.
*/

inline int isLeft(GEO_Point p, Edge e){
	/* Cross Product. */
	//printf("edge: {%f, %f}-{%f, %f}\tp:{%f, %f}\n", e.p1.longitude, e.p1.latitude, 
	//	e.p2.longitude, e.p2.latitude, p.longitude, p.latitude);

	return ((e.p2.longitude - e.p1.longitude)*(p.latitude - e.p1.latitude) - 
		(p.longitude - e.p1.longitude)*(e.p2.latitude - e.p1.latitude));
}

inline bool upwards_cross(Edge e, GEO_Point p){
	return (e.p1.latitude <= p.latitude) && (e.p2.latitude > p.latitude);
}

inline bool downwards_cross(Edge e, GEO_Point p){
	return (e.p2.latitude <= p.latitude);
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







#if 0
int areIntersecting(Segment side1, Segment side2){
    float d1, d2;
    float a1, a2, b1, b2, c1, c2;

    // Convert vector 1 to a line (line 1) of infinite length.
    // We want the line in linear equation standard form: A*x + B*y + C = 0
    // See: http://en.wikipedia.org/wiki/Linear_equation
    a1 = side1.p2.latitude - side1.p1.latitude;
    b1 = side1.p1.longitude - side1.p2.longitude;
    c1 = (side1.p2.longitude * side1.p1.latitude) - (side1.p1.longitude * side1.p2.latitude);

    // Every point (x,y), that solves the equation above, is on the line,
    // every point that does not solve it, is not. The equation will have a
    // positive result if it is on one side of the line and a negative one 
    // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector
    // 2 into the equation above.
    d1 = (a1 * side2.p1.longitude) + (b1 * side2.p1.latitude) + c1;
    d2 = (a1 * side2.p2.longitude) + (b1 * side2.p2.latitude) + c1;

    // If d1 and d2 both have the same sign, they are both on the same side
    // of our line 1 and in that case no intersection is possible. Careful, 
    // 0 is a special case, that's why we don't test ">=" and "<=", 
    // but "<" and ">".
    if (d1 > 0 && d2 > 0) return 0;
    if (d1 < 0 && d2 < 0) return 0;

    // The fact that vector 2 intersected the infinite line 1 above doesn't 
    // mean it also intersects the vector 1. Vector 1 is only a subset of that
    // infinite line 1, so it may have intersected that line before the vector
    // started or after it ended. To k0w for sure, we have to repeat the
    // the same test the other way round. We start by calculating the 
    // infinite line 2 in linear equation standard form.
    a2 = side2.p2.latitude - side2.p1.latitude;
    b2 = side2.p1.longitude - side2.p2.longitude;
    c2 = (side2.p2.longitude * side2.p1.latitude) - (side2.p1.longitude * side2.p2.latitude);

    // Calculate d1 and d2 again, this time using points of vector 1.
    d1 = (a2 * side1.p1.longitude) + (b2 * side1.p1.latitude) + c2;
    d2 = (a2 * side1.p2.longitude) + (b2 * side1.p2.latitude) + c2;

    // Again, if both have the same sign (and neither one is 0),
    // 0 intersection is possible.
    if (d1 > 0 && d2 > 0) return 0;
    if (d1 < 0 && d2 < 0) return 0;

    // If we get here, only two possibilities are left. Either the two
    // vectors intersect in exactly one point or they are collinear, which
    // means they intersect in any number of points from zero to infinite.
    if ((a1 * b2) - (a2 * b1) == 0.0f) return 2;

    // If they are not collinear, they must intersect in exactly one point.
    return 1;
}


//TODO: ray, and sides like (x1/y1)-(x2/y2)
bool isSampleInRangeGeneral(GPSSamp* samp, Zone_general* zone_gen){
	// find X,Y min and max each.
	double Xmin = 190, Xmax = -1;
	double Ymin = 100, Ymax = -1;
	int i;
	for(i = 0; i < zone_gen->numVertices; i++){
		printf("x%d: %f, y%d: %f || ",i, i, zone_gen->vertices[i].longitude, zone_gen->vertices[i].latitude);
		if(zone_gen->vertices[i].longitude < Xmin)
			Xmin = zone_gen->vertices[i].longitude;
		if(zone_gen->vertices[i].latitude < Ymin)
			Ymin = zone_gen->vertices[i].latitude; 
	}
	for(i = 0; i < zone_gen->numVertices; i++){
		if(zone_gen->vertices[i].longitude > Xmax)
			Xmax = zone_gen->vertices[i].longitude;
		if(zone_gen->vertices[i].latitude > Ymax)
			Ymax = zone_gen->vertices[i].latitude; 
	}
	printf("xmin: %f, xmax: %f, ymin: %f, ymax: %f\n", Xmin, Xmax, Ymin, Ymax);
	double e = ((Xmax - Xmin) / 100);

	Segment sides[zone_gen->numVertices];
	//double sidesCalc[zone_gen->numVertices];
	for(i = 0; i < zone_gen->numVertices-1; i++){
		sides[i].p1.longitude = zone_gen->vertices[i].longitude;
		sides[i].p1.latitude = zone_gen->vertices[i].latitude;

		sides[i].p2.longitude = zone_gen->vertices[i+1].longitude;
		sides[i].p2.latitude = zone_gen->vertices[i+1].latitude;
		//sidesCalc[i] = (sides[i].p1.longitude/sides[i].p1.latitude) - 
		//(sides[i].p2.longitude/sides[i].p2.latitude);
	}

	sides[zone_gen->numVertices-1].p1.longitude = zone_gen->vertices[zone_gen->numVertices-1].longitude;
	sides[zone_gen->numVertices-1].p1.latitude = zone_gen->vertices[zone_gen->numVertices-1].latitude;

	sides[zone_gen->numVertices-1].p2.longitude = zone_gen->vertices[0].longitude;
	sides[zone_gen->numVertices-1].p2.latitude = zone_gen->vertices[0].latitude;
	//sidesCalc[zone_gen->numVertices-1] = (sides[zone_gen->numVertices-1].p1.longitude/sides[zone_gen->numVertices-1].p1.latitude) - 
	//	(sides[0].p2.longitude/sides[0].p2.latitude);

	Segment ray = { .p1.longitude = samp->longitude, .p1.latitude = samp->latitude,
					.p2.longitude = Xmax + e, .p2.latitude = samp->latitude };

	//double rayCalc = ( ray.p1.longitude/ray.p1.latitude) - (ray.p2.longitude + ray.p2.latitude);
	
	/* test intersections */
	int intersections = 0;
	for(i = 0; i < zone_gen->numVertices; i++){
		if(areIntersecting(ray, sides[i]))
			intersections++;
	}

	if((intersections % 2) == 1)
		return true; // inside polygon
	return false; //outside
}	
#endif

bool isSampleInRange(GPSSamp* samp, Zone* zone) {
	//The simplest check of a body within a rectangle
	if(samp->altitude > zone->altitude) 
		return false;

	if(samp->latitude >= max(zone->p1.latitude, zone->p2.latitude) || 
		samp->latitude <= min(zone->p1.latitude, zone->p2.latitude))
		return false;

	if(samp->longitude >= max(zone->p1.longitude, zone->p2.longitude) || 
		samp->longitude <= min(zone->p1.longitude, zone->p2.longitude))
		return false;

	return true;
}